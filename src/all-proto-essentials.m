// Intrinsic that creates all proto-essentials

// Implements the algorithm described in Appendix B of [PS] to find all overgroups
// of G which contain H as a Sylow p-subgroup. This implementation isn't quite as general as that
// Assume that $H/Inn$ (which will be Out_S(E)) is cyclic of order p
function OvergroupsSylowEmbedded(G, H, Inn, p)
    //{Creates overgrps of H in G which have H as a sylow p-subgroup and such that they are generated by conjugates of H. To get the full list we will use the Frattini argument}
    if not IsPrime(p) then
        error "p is not a prime number";
    end if;
    if not #H mod p eq 0 then
        error "|H| is not divisible by p";
    end if;
    if not IsNormal(G,Inn) then
        error "Inn is not normal in G";
    end if;
    J := Sylow(H,p);
    JJ, quomap:= J/Inn;
    if not IsCyclic(JJ) then
        error "H/Inn does not have cyclic Sylow subgroups";
    end if;




    NGH:= Normalizer(G,J);
    JJJ:= Generators(JJ); 
    JJJ:= {j: j in JJJ|Order(j) eq #JJ};
    J1:= Inverse(quomap)(Rep(JJJ)); // So J1 generates J mod Inn and it is an element
    AllOvers:={};
    ONew:={SubnormalClosure(G,H)};
    while ONew ne {H} do 
        Overs := ONew diff AllOvers;  
        j:= 0;
        AllOvers := AllOvers join ONew; 
        ONew:={H};
        for X in Overs do  
            j:= j+1;  
            // Step (1)
            X_inf:=SubnormalClosure(X,H); 
            // Step (2)
            maximals := [M`subgroup : M in MaximalSubgroups(X_inf)];
            AM:=[];
            for M in maximals do 
                // Check that Inn is in M and |M| is divisible by |H|
                if Inn subset M and #M mod #H eq 0 then 
                    for M_conj in ConjugacyClasses(M) do  
                        // Step (3)
                        is_conj, g := IsConjugate(X_inf,M_conj[3],J1); 
                        if is_conj then 
                            Mg:= M^g;  
                            for am in AM do 
                                aaa, bbb := IsConjugate(NGH,am,Mg); 
                                if aaa then 
                                    continue M_conj;  
                                end if;
                            end for;  
                            AM:= AM cat [SubnormalClosure(Mg,H)]; 
                        end if; 
                    end for;//M_conj
                end if;//Inn subset M
            end for; //M in maximals   



                
            AM:= Seqset(AM);             
            for xx in AM do 
                xxin := false;
                for yy in ONew do 
                    if xx subset yy then 
                        xxin := true; 
                        continue xx; 
                    end if; 
                end for;
                if xxin eq false then
                    ONew := ONew join {xx};
                end if;
            end for; 

            ONew1 :={Rep(ONew)};
            for on in ONew do 
                OUT := true;
                for on1 in ONew1 do  
                    if IsConjugate(NGH,on,on1) then 
                        OUT := false; 
                        continue on; 
                    end if; 
                end for;
                if OUT then 
                    ONew1 := ONew1 join{on}; 
                end if;
            end for;
            ONew :=ONew1;
        end for;
    end while;












    AllOvers1:= {Rep(AllOvers)};
    for on in AllOvers do 
        OUT := true;
        for on1 in AllOvers1 do  
            if IsConjugate(NGH,on,on1) then 
                OUT := false; 
                continue on; 
            end if; 
        end for;
        if OUT then 
            AllOvers1 := AllOvers1 join{on}; 
        end if;
    end for;
    AllOvers:= AllOvers1;

    AAM:=[x: x in AllOvers|Index(x,H) mod p ne 0];
    return AAM;
end function;



// Function that creates a record containing all the automorphism parts we name
// Saves a lot of copy and pasting and makes it a bit more maintainable
// Downside is it might do more than needed in some cases
function RecordPAutos(S, P)
    MakeAutos(P);
    PAutosRec := recformat<AutP, mapP, AutPp, InnP, InnPp, AutSP, AutSPp, OutSPp>;
    AutSP:=AutYX(Normalizer(S,P),P );
    mapP:= P`autopermmap; 
    AutSPp:=sub<P`autoperm|{mapP(g): g in Generators(AutSP)}>;
    InnPp:=sub<P`autoperm|{mapP(g): g in Generators(Inn(P))}>;
    PAutos := rec<PAutosRec |
        AutP:=P`autogrp,
        mapP:= P`autopermmap,
        AutPp:= P`autoperm,
        InnP:=Inn(P),
        InnPp := InnPp,
        AutSP:= AutSP,
        AutSPp:= AutSPp,
        OutSPp:= AutSPp/InnPp>;
    return PAutos;
end function;



// Procedure that obtains some protoessentials depending on whether S is max class or not
procedure MaxClassTest(S,S_centrics, ~ProtoEssentials)
    p:= GetPrime(S); 
    nn:= Valuation(#S,p);
    if IsMaximalClass(S) and #S ge p^5 then 
        LL:= LowerCentralSeries(S);  
        // T will be the set of protoessentials that are pearls and the two step centralisers of index p
        T:=[];
        // Calculate the two step centralisers C_S(Z_2(S)) and \gamma_1(S)
        C_1 := Centralizer(S, LL[2],LL[4]);
        C_2 := Centralizer(S, LL[nn-2]);
        Append(~T, C_1);
        if not C_1 eq C_2 then 
            Append(~T,C_2); 
        end if; 
        // By Grazian and Parker a pearl is not contained in C_1 or C_2 but does contain Z(S) or Z_2(S)
        T:= T cat [x:x in S_centrics| #x eq p^2 and LL[nn-1] subset x and not x subset C_1 and not x subset C_2] 
            cat 
            [x:x in S_centrics| #x eq p^3 and LL[nn-2] subset x and not x subset C_1 and not x subset C_2]; 
        TT:=[];
        // For each element of T check if it is radical
        for x in T do 
            if not IsRadical(S,x) then 
                continue x; 
            end if;
            Append(~TT,x);
        end for;         
        ProtoEssentials := TT;
    end if; 

            
    if not IsMaximalClass(S) or #S le p^4 then  
        for x in S_centrics do   
            if x eq S then 
                continue x; 
            end if; 
            if IsCyclic(x) then  
                continue x; 
            end if;
            if not IsRadical(S,x) then 
                continue x; 
            end if;
            Nx:=Normalizer(S,x);
            A:=AutYX(Nx,x);
            Ap:= SubMap(x`autopermmap,x`autoperm ,A);
            Innerp:= SubMap(x`autopermmap,x`autoperm , Inn(x));
            P:= Index(Ap,Innerp);
            Frat:=FrattiniSubgroup(x);
            FQTest := Index(x,Frat) ge P^2;
            //This is a bound obtained by saying that $\Out_\F(x)$ acts faithfully on $x/\Phi(x)$.  
            //The order of such faithful modules is at least $|\Out_S(x)|^2$.
            if not FQTest then 
                continue x; 
            end if; 
            SylTest, QC:=IsStronglypSylow(Ap/Innerp);
            //If $x$ is essential, then $\Out_F(x)$ should have a strongly $p$-embedded. 
            //Here we check that the Sylow $p$-subgroup is compatible with this.
            if not SylTest then 
                continue x; 
            end if; 
            if not QC and IsSoluble(x`autoperm)  then   
                continue x; 
            end if; 
            ProtoEssentials:= Append(ProtoEssentials,x); 
        end for;
    end if;
end procedure;





function NonQC(P, PAutos, M)
    p := GetPrime(P);
    ZZ:= Integers(); //Integer Ring
    // If Out_S(E) is not QC then Out_F(E) is not soluble, 4.6 of [PS]
    // We obtain all non soluble subgroups with p-part equal to |Aut_S(P)|
    pVal:=Valuation(#PAutos`AutPp,p); // i.e. p-part of Aut(P) is pVal
    NormVal:=Valuation(#PAutos`AutSPp,p);
    Mbgs:= NonsolvableSubgroups(M:OrderDividing:= ZZ!(#PAutos`AutPp/((p^(pVal-NormVal)))));
    AutPCandidates:= [sub<PAutos`AutPp|xx`subgroup,PAutos`InnPp> :xx in Mbgs
                        |Valuation(#sub<PAutos`AutPp|xx`subgroup,PAutos`InnPp>,p) eq NormVal];
    APC:=[]; 
    //Now pick out the ones that have AutSPp as a Sylow.
    for kk in [1..#AutPCandidates] do  
        GG:= AutPCandidates[kk];
        Sylow:=SylowSubgroup(GG,p);
        a,b:=IsConjugate(PAutos`AutPp,Sylow,PAutos`AutSPp);
        if a then 
            Append(~APC,GG^b); 
        end if; 
    end for;
    return APC;
end function;


function QCNonAbelian(P, PAutos, M)
    p := GetPrime(P);
    ZZ:= Integers(); //Integer Ring
    pVal:=Valuation(#PAutos`AutPp,p); 
    NormVal:=Valuation(#PAutos`AutSPp,p);
    Mbgs:= Subgroups(M, PAutos`InnPp:   OrderDividing:= ZZ!(#PAutos`AutPp/(p^(pVal-NormVal))));
    AutPCandidates:= [sub<PAutos`AutPp|xx`subgroup,PAutos`InnPp> :xx in Mbgs
                        |Valuation(#xx`subgroup,p) eq NormVal];
    APC:=[];//Now pick out the ones that have AutSPp as a Sylow.
    for kk in [1..#AutPCandidates] do  
        GG:= AutPCandidates[kk];
        Sylow:=SylowSubgroup(GG,p);
        a,b:=IsConjugate(PAutos`AutPp,Sylow,PAutos`AutSPp);
        if a then 
            Append(~APC,GG^b); 
        end if; 
    end for;
    return APC;
end function;







intrinsic AllProtoEssentials(S::Grp:OpTriv:=false, pPerfect:= false, Printing:= false)-> SeqEnum
    {Makes all protosessentials up to automorphisms of S the parameters ask for  O_p(F)=1 and O^p(\F)= \F}
    p:= GetPrime(S); 
    nn:= Valuation(#S,p);
    //Here are automorphisms of S and centric subgroups of S
    S:= PCGroup(S);
    MakeAutos(S);
    // Create a list of S-centric subgroups
    Sbar, bar:= S/Centre(S);
    TT:= Subgroups(Sbar);
    S_centrics:= [Inverse(bar)(x`subgroup):x in TT|IsSCentric(S,Inverse(bar)(x`subgroup))];

    if Printing eq true then 
        print "The group has", #S_centrics, "centric subgroups"; 
    end if;

    ProtoEssentials:=[];
    // If S has max class we can be more efficient obtaining a first set of protoessentials
    MaxClassTest(S,S_centrics, ~ProtoEssentials);
    if  #ProtoEssentials eq 0 then 
        return []; 
    end if; 

    ///If E is protoessential, then so is E\alpha for alpha in Aut S so we add in the orbits under Aut S
    ProtoEssentialAutClasses:= Setseq({Set(AutOrbit(S,PE,S`autogrp)):PE in ProtoEssentials});
    // Now pick representatives
    ProtoEssentialAutClasses:= [Rep(x):x in ProtoEssentialAutClasses];
    
    // Test if there is an invariant essential already in which case O_p(F) \neq 1 
    if OpTriv then 
        if CharSbgrpTest(ProtoEssentials,S) then 
            return []; 
        end if; 
    end if;

    // Calculate the proto-essential focal subgroup H \geq foc(F), hence if H \neq S then foc(F) \neq S and O^p(F) \neq F
    if pPerfect then 
        H:= sub<S|ProtoEssentials,{x^-1*a(x):a in Generators(S`autogrp), x in S}>; 
        if  H ne S then 
            return []; 
        end if; 
    end if;
    
    // Here we  make all the candidates for Out_\F(x) for x in ProtoEssentials 
    // and check that they have strongly p-embedded subgroups.
    for i in [1..#ProtoEssentialAutClasses] do 
        P:= ProtoEssentialAutClasses[i];
        PAutos := RecordPAutos(S,P);
        M:=SubnormalClosure(PAutos`AutPp,PAutos`AutSPp);

        // Generate candidates differently based on structure of Out_S(E)
        QC:=IsQuaternionOrCyclic(PAutos`OutSPp);
        if not QC then
            AutPCandidates := NonQC(P, PAutos, M);
        end if;
        if QC and IsCyclic(PAutos`OutSPp) then
            AutPCandidates:= OvergroupsSylowEmbedded(M,PAutos`AutSPp,PAutos`InnPp,p);
        end if;  
        if QC and not IsAbelian(PAutos`OutSPp) then  
            AutPCandidates := QCNonAbelian(P, PAutos, M);
        end if;


        //This is where we store all potential Aut_F(P) up to Aut(P) conjugacy.
        P`autF:=[];
        for GG in AutPCandidates do
            if  IsStronglypEmbeddedMod(GG,PAutos`InnPp,p) eq false then 
                continue GG; 
            end if;
            NGG:= Normalizer(PAutos`AutPp,GG);  
            NGGsubs:=[sub<PAutos`AutPp|xx`subgroup> :xx in Subgroups(NGG: OrderMultipleOf :=#GG)| 
                        GG subset xx`subgroup and Index(xx`subgroup,GG) mod p ne 0];
            for GGs in NGGsubs do 
                Append(~P`autF,sub<PAutos`AutP|{Inverse(PAutos`mapP)(g): g in Generators(GGs)}>); 
            end for; 
        end for;
    end for;

    // Now run through the proto-essentials that have passed all tests and remove non-trivial
    ProtoEssentialAutClasses:= [x:x in ProtoEssentialAutClasses|assigned(x`autF)];
    ProtoEssentialAutClasses:= [x:x in ProtoEssentialAutClasses|#x`autF ne 0];

    if Printing then 
        print "The set ProtoEssentialAutClasses has ", #ProtoEssentialAutClasses," elements";  
    end if;
    if Printing then 
        for x in ProtoEssentialAutClasses do  
            print "The protoessential aut class representative has ", #x`autF, "potential automorphism groups"; 
         end for; 
    end if;
    return ProtoEssentialAutClasses;
end intrinsic;
